Assignment 3

Due March 23, 2015 at 11:55pm.

This assignment is worth 15 assignment marks.  Submit your work in one file under the name (your ID#).pl.

In this assignment, you can use any built-in predicates. Your programs should not get into infinite loop for the specified invocation patterns.  An infinite loop refers to (1) the execution of a query w.r.t. your program is non-terminating (that the execution runs out of memory is not considered a termination), or (2) it gives you an infinite number of answers when there are in fact only finitely many.

Since the use of cut will not be introduced formally in the early lectures (but certainly before this assignment is due), you may choose to solve a question in this assignment in the following way: first, write a program for it without worrying about the no-infinite-loop requirement; in this case, you want to make sure the first answer generated by Prolog is correct. Then, add the cut into your program later and at the same time possibly remove some conditions in a clause's body that give you the same effect.  Once you understand the cut, this work is straightforward.

As a convention in Prolog's documentation, when we specify a predicate, a parameter headed with + means it is an input parameter--it's bound when the predicate is called, and a parameter headed with - is an output parameter--it's a variable when the predicate is called and bound to a value when the predicate is proved. A parameter headed by ? means it can be either input or output parameter. Your solutions will be tested according to this specification.


1 (1 mark)

Define a predicate

setDifference(+S1,+S2,-S3)

where S1 and S2 are lists of atoms, and S3 is a list of those atoms that are in S1 but not in S2.  E.g.

?- setDifference([a,b,f,c,d],[e,b,a,c],S).
S=[f,d]

where the order of the resulting elements is unimportant. Assume S1 and S2 do not contain duplicated elements.

2  (1 mark)

Define a predicate

swap(+L, -R)

where L is a list of atoms or numbers and R is obtained from L such that the 1st two elements in L are swapped positions, so are the next two, and so on. If the number of elements in L is odd, then the last element is left as is. E.g,

?- swap([a,1,b,2], W).
W = [1,a,2,b].

?- swap([a,1,b], W).
W = [1,a,b].

Note that L may be empty, in which case R should be empty too.

3  (3 mark)

Define two predicates in this question. First, define

rmDup(+L, -R)

where L is a list of atoms and R is the same as L except duplicated elements are removed.

?- rmDup([a,b,c,c,a,d,a], W).

W = [a,b,c,d].

The order in the resulting list is unimportant.

Then, define

rmAllDup(+L, -R)

where L is a possibly nested list, and R is the same as L except all duplicated elements are removed.

?- rmAllDup([a,[b,c],c,[a,d,a]], W).

W = [a,[b,c],[d]]

?- rmAllDup([a,[b,c],c,[a,c,e,[a]]], W).

W = [a,[b,c],[e,[]]]

It is required that the structure of the given list be preserved, i.e., the first occurrence of an atom is kept and any repeated atom, wherever it may be, is removed and structure is not altered

4  (3 marks)

Define a predicate

generate(+L,+Choice, -N)

where L is a possibly nested list of numbers and, if Choice is smallest, N is the smallest among them and if Choice is largest, N is the largest among them. We assume L is non-empty. E.g.

 ?- generate([3,4,[5,2],[1,7,2]],smallest,N).

N=1.

?- generate([3,4,[5,2],[1,7,2]],largest,N).

N=7.

5 (3 marks)

Define a predicate

countAll(+L,-N)

such that given a possibly nestedlist L of atoms, the number of occurrences of every atom is counted. Thus, N should be a list of pairs [a,n] representing that atom a occurs in L n times. These pairs should appear in a non-increasing order. E.g.

?- countAll([a,b,[e,c],c,[b]],N).

N = [[b,2],[c 2],[a,1],[e,1]]

For atoms with the same account, the order is unimportant.

Hint: First, get the occurrences counted, and then define a predicate that does the sorting. You can adopt any sorting algorithm, and you are allowed to adopt any Prolog code for sorting that you find online or in any book or tutorial. In this case, please acknowledge the source. 


6  (4 Marks)

The question is about string conversion. Define a predicate

convert(+Term,-Result)

with the following specification.

Term is a list (possibly empty) of single letters representing a string with the convention:

* e represents an empty space
* q represents a single quote

Functionality:

Given Term, Result should hold the same Term except that

* anything between two matching q's are not changed;
* any e's outside of a pair of matching q's are removed;
* any letter outside a pair of matching q's is changed to letter c;
* an unmatched q will be left as is.

Definition of matching q's:

Any string with an odd number of occurrences of q has the last occurrence of q unmatched; all the preceding ones are matched as: the first and second form a pair, the 3rd and the 4th form the next pair, and so on.

Examples:

?- convert([e,e,a,e,b,e],R)
R = [c,c] ?;
no

?- convert([e,q,a,b,e,e],R).
R = [q,c,c]?;
no

?- convert([e,a,e,e],R).
R = [c]?;
no

?- convert([e,q,a,e,b,q,e,a,e],R).
R = [q,a,e,b,q,c]? ;
no

?- convert([a,q,e,l,q,r,e,q,b,e],R).
R = [c,q,e,l,q,c,q,c]? ;
no

?- convert([q,e,q,b,q,e,l,q,a,e],R).
R = [q,e,q,c,q,e,l,q,c] ? ;
no

In this question, you can use the list library of Sicstus Prolog by declaring

:- use_module(library(lists)).


Hints:

* Remove spaces and change any non-space char to letter c before hitting the first q;
* After hitting a single quote, find the next quote; if fail (thus dangling quote), change all non-space char's to letter c and remove all spaces;
* Otherwise, the next quote is found, then copy the string between the matching quotes as part of the resulting string, and continue with the rest of the string.

To locate a symbol, say q, in a list L, you can use

append(L1,[q|L2],L)

If q occurs in L multiple times, by backtracking you will get all possible L1 and L2 such that, with an occurrence of q in front of L2, the appending of the two yields L. To understand this, try it before you adopt it, e.g.,

?- append(L1,[q|L2], [a,b,q,r,q,q,a]).

L1 = [a,b],

L2 = [r,q,q,a] ? ;

L1 = [a,b,q,r],

L2 = [q,a] ? ;

L1 = [a,b,q,r,q],

L2 = [a] ? ;

no